<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finger Ninja</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }

        #score {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #timer {
            font-size: 32px;
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #gameOverScreen {
            display: none;
        }

        h1 {
            color: #FFD700;
            font-size: 72px;
            margin-bottom: 20px;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.8);
        }

        .subtitle {
            color: white;
            font-size: 24px;
            margin-bottom: 40px;
        }

        button {
            padding: 20px 60px;
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 30px rgba(0,0,0,0.4);
        }

        button:active {
            transform: translateY(0);
        }

        #finalScore {
            color: #FFD700;
            font-size: 64px;
            margin: 20px 0;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
        }

        .lives {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 36px;
            color: #ff4444;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="loading">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    <div id="container">
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
        <canvas id="gameCanvas"></canvas>

        <div id="ui">
            <div id="score">0</div>
            <div id="timer">60</div>
        </div>

        <div class="lives" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>

        <div id="startScreen">
            <h1>ü•∑ FINGER NINJA ü•∑</h1>
            <p class="subtitle">–†–∞–∑—Ä–µ–∑–∞–π—Ç–µ —Ñ—Ä—É–∫—Ç—ã –ø–∞–ª—å—Ü–µ–º, –∏–∑–±–µ–≥–∞–π—Ç–µ –±–æ–º–±!</p>
            <button onclick="startGame()">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
        </div>

        <div id="gameOverScreen">
            <h1>–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê!</h1>
            <div id="finalScore">0</div>
            <button onclick="restartGame()">–ò–ì–†–ê–¢–¨ –°–ù–û–í–ê</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const gameCanvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameCtx = gameCanvas.getContext('2d');
        const loading = document.getElementById('loading');

        let score = 0;
        let timeLeft = 60;
        let lives = 3;
        let gameActive = false;
        let fingerTip = null;
        let fruits = [];
        let sliceTrail = [];
        let particles = [];
        let gameTimer = null;
        let spawnTimer = null;

        // –ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSliceSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function playBombSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }

        // –ö–ª–∞—Å—Å—ã —Ñ—Ä—É–∫—Ç–æ–≤
        const fruitTypes = [
            { name: 'apple', color: '#ff4444', emoji: 'üçé', points: 10 },
            { name: 'orange', color: '#ff8833', emoji: 'üçä', points: 10 },
            { name: 'banana', color: '#ffee33', emoji: 'üçå', points: 15 },
            { name: 'watermelon', color: '#44ff88', emoji: 'üçâ', points: 20 },
            { name: 'bomb', color: '#333333', emoji: 'üí£', points: -50, isBomb: true }
        ];

        class Fruit {
            constructor() {
                const type = Math.random() < 0.15 ? fruitTypes[4] : fruitTypes[Math.floor(Math.random() * 4)];
                this.type = type;
                // –°–ø–∞–≤–Ω –≤ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π 70% –æ–±–ª–∞—Å—Ç–∏ —ç–∫—Ä–∞–Ω–∞ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                const margin = gameCanvas.width * 0.15;
                this.x = margin + Math.random() * (gameCanvas.width - margin * 2);
                
                // –°–ø–∞–≤–Ω —Å–Ω–∏–∑—É –∑–∞ —ç–∫—Ä–∞–Ω–æ–º
                this.y = gameCanvas.height + 50;
                
                // –ë–æ–ª–µ–µ —Å–∏–ª—å–Ω—ã–π –Ω–∞—á–∞–ª—å–Ω—ã–π –∏–º–ø—É–ª—å—Å –≤–≤–µ—Ä—Ö –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –≤–µ—Ä—Ö–Ω–µ–π –ø–æ–ª–æ–≤–∏–Ω—ã —ç–∫—Ä–∞–Ω–∞
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = -(14 + Math.random() * 8); // –£–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤–≤–µ—Ä—Ö
                
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.15;
                this.size = 50 + Math.random() * 20;
                this.sliced = false;
                this.gravity = 0.4; // –ù–µ–º–Ω–æ–≥–æ —É–≤–µ–ª–∏—á–µ–Ω–Ω–∞—è –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–π –¥—É–≥–∏
            }

            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                gameCtx.save();
                gameCtx.translate(this.x, this.y);
                gameCtx.rotate(this.rotation);
                gameCtx.font = `${this.size}px Arial`;
                gameCtx.textAlign = 'center';
                gameCtx.textBaseline = 'middle';
                gameCtx.fillText(this.type.emoji, 0, 0);
                gameCtx.restore();
            }

            isOffScreen() {
                return this.y > gameCanvas.height + 100;
            }

            checkCollision(x, y) {
                const dx = this.x - x;
                const dy = this.y - y;
                return Math.sqrt(dx * dx + dy * dy) < this.size / 2;
            }

            slice() {
                if (this.sliced) return;
                this.sliced = true;

                // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü
                for (let i = 0; i < 15; i++) {
                    particles.push({
                        x: this.x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10 - 5,
                        color: this.type.color,
                        size: Math.random() * 8 + 4,
                        life: 1
                    });
                }

                if (this.type.isBomb) {
                    playBombSound();
                    lives--;
                    updateLives();
                    if (lives <= 0) {
                        endGame();
                    }
                    // –≠—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞
                    for (let i = 0; i < 30; i++) {
                        particles.push({
                            x: this.x,
                            y: this.y,
                            vx: (Math.random() - 0.5) * 20,
                            vy: (Math.random() - 0.5) * 20,
                            color: '#ff6600',
                            size: Math.random() * 12 + 6,
                            life: 1
                        });
                    }
                } else {
                    playSliceSound();
                    score += this.type.points;
                    updateScore();
                }
            }
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
        }

        function updateTimer() {
            document.getElementById('timer').textContent = timeLeft;
        }

        function updateLives() {
            document.getElementById('lives').textContent = '‚ù§Ô∏è'.repeat(lives);
        }

        function spawnFruit() {
            if (!gameActive) return;
            fruits.push(new Fruit());
        }

        function updateGame() {
            if (!gameActive) return;

            // –û—á–∏—Å—Ç–∫–∞ –∏–≥—Ä–æ–≤–æ–≥–æ canvas
            gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ñ—Ä—É–∫—Ç–æ–≤
            fruits = fruits.filter(fruit => {
                fruit.update();
                if (!fruit.sliced) {
                    fruit.draw();
                }
                
                if (fruit.isOffScreen() && !fruit.sliced && !fruit.type.isBomb) {
                    // –§—Ä—É–∫—Ç —É–ø–∞–ª - –º–∏–Ω—É—Å –∂–∏–∑–Ω—å
                    lives--;
                    updateLives();
                    if (lives <= 0) {
                        endGame();
                    }
                    return false;
                }
                
                return !fruit.isOffScreen();
            });

            // –°–ª–µ–¥ –ø–∞–ª—å—Ü–∞
            if (sliceTrail.length > 0) {
                gameCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                gameCtx.lineWidth = 5;
                gameCtx.lineCap = 'round';
                gameCtx.beginPath();
                gameCtx.moveTo(sliceTrail[0].x, sliceTrail[0].y);
                for (let i = 1; i < sliceTrail.length; i++) {
                    gameCtx.lineTo(sliceTrail[i].x, sliceTrail[i].y);
                }
                gameCtx.stroke();

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å–æ —Å–ª–µ–¥–æ–º
                sliceTrail.forEach(point => {
                    fruits.forEach(fruit => {
                        if (!fruit.sliced && fruit.checkCollision(point.x, point.y)) {
                            fruit.slice();
                        }
                    });
                });
            }

            // –ß–∞—Å—Ç–∏—Ü—ã
            particles = particles.filter(p => {
                p.vy += 0.3;
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;

                if (p.life > 0) {
                    gameCtx.fillStyle = p.color;
                    gameCtx.globalAlpha = p.life;
                    gameCtx.beginPath();
                    gameCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    gameCtx.fill();
                    gameCtx.globalAlpha = 1;
                    return true;
                }
                return false;
            });

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –ø–∞–ª—å—Ü–∞ - —è—Ä–∫–∞—è –∂—ë–ª—Ç–∞—è —Ç–æ—á–∫–∞
            if (fingerTip) {
                // –í–Ω–µ—à–Ω–µ–µ —Å–≤–µ—á–µ–Ω–∏–µ
                gameCtx.shadowBlur = 20;
                gameCtx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                gameCtx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                gameCtx.beginPath();
                gameCtx.arc(fingerTip.x, fingerTip.y, 18, 0, Math.PI * 2);
                gameCtx.fill();
                
                // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫—Ä—É–≥
                gameCtx.shadowBlur = 0;
                gameCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                gameCtx.beginPath();
                gameCtx.arc(fingerTip.x, fingerTip.y, 8, 0, Math.PI * 2);
                gameCtx.fill();
            }

            requestAnimationFrame(updateGame);
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            score = 0;
            timeLeft = 60;
            lives = 3;
            fruits = [];
            particles = [];
            gameActive = true;
            updateScore();
            updateTimer();
            updateLives();

            // –¢–∞–π–º–µ—Ä –∏–≥—Ä—ã
            gameTimer = setInterval(() => {
                timeLeft--;
                updateTimer();
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);

            // –°–ø–∞–≤–Ω —Ñ—Ä—É–∫—Ç–æ–≤
            spawnTimer = setInterval(spawnFruit, 800);

            updateGame();
        }

        function endGame() {
            gameActive = false;
            clearInterval(gameTimer);
            clearInterval(spawnTimer);
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            startGame();
        }

        // MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        function onResults(results) {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8]; // –ö–æ–Ω—á–∏–∫ —É–∫–∞–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –ø–∞–ª—å—Ü–∞

                // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (–æ—Ç–∑–µ—Ä–∫–∞–ª–µ–Ω–æ –¥–ª—è –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
                const x = (1 - indexTip.x) * gameCanvas.width;
                const y = indexTip.y * gameCanvas.height;

                fingerTip = { x, y };

                // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ —Å–ª–µ–¥
                sliceTrail.push({ x, y });
                if (sliceTrail.length > 15) {
                    sliceTrail.shift();
                }
            } else {
                sliceTrail = [];
                fingerTip = null;
            }

            ctx.restore();
        }

        function drawConnectors(ctx, landmarks, connections, style) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            connections.forEach(([start, end]) => {
                const startPoint = landmarks[start];
                const endPoint = landmarks[end];
                ctx.beginPath();
                ctx.moveTo((1 - startPoint.x) * canvas.width, startPoint.y * canvas.height);
                ctx.lineTo((1 - endPoint.x) * canvas.width, endPoint.y * canvas.height);
                ctx.stroke();
            });
        }

        function drawLandmarks(ctx, landmarks, style) {
            ctx.fillStyle = style.color;
            landmarks.forEach(landmark => {
                ctx.beginPath();
                ctx.arc((1 - landmark.x) * canvas.width, landmark.y * canvas.height, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        const HAND_CONNECTIONS = [
            [0,1],[1,2],[2,3],[3,4],
            [0,5],[5,6],[6,7],[7,8],
            [5,9],[9,10],[10,11],[11,12],
            [9,13],[13,14],[14,15],[15,16],
            [13,17],[17,18],[18,19],[19,20],[0,17]
        ];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–∞–º–µ—Ä—ã
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    gameCanvas.width = video.videoWidth;
                    gameCanvas.height = video.videoHeight;
                    
                    loading.style.display = 'none';
                    
                    const camera = new Camera(video, {
                        onFrame: async () => {
                            await hands.send({image: video});
                        },
                        width: video.videoWidth,
                        height: video.videoHeight
                    });
                    camera.start();
                };
            } catch (error) {
                loading.textContent = '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ. –†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ.';
                console.error('Camera error:', error);
            }
        }

        initCamera();
    </script>
</body>
</html>